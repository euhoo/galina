Very simple library for driving your app's state.
Данная библиотека вдохновлена Redux и использует некоторые ее идеи.
Использовать можно не только с React. 
Оглавление
1.Компонент, загружающий данные в хранилище.  
2.Компонент, получающий данные из хранилища.
3.Настройка storeConstructors. аналог reducers в redux
4.Дополнительные возможности

Ниже описание использования библиотеки на примере в /example для React:
1. В компоненте, который загружает данные в хранилище(в примере /example/components/InputComponent.jsx):  
    а)импортируй класс  
    ```aidl
    import Galinka from '../../galinka';
    ```
    б)создай новый инстанс класса. Аргументом передай название хранилища.  
    ```aidl
    const inputStore = new Galinka('toDos');
    ``` 
    Данный инстанс будет использоваться для взаимодействия с хранилищем. Если в компоненте используются разные хранилища, то  необходимо создавать разные инстансы класса Galinka.  
    в)для того, чтобы поместить данные в хранилище на инстансе Galinka для данного хранилища(определяем по названию, переданному при инициализации инстанса) вызови метод inputStore.updateStore('add', data); :  
     ```aidl
       inputStore.updateStore('add', data);
     ```
   где первый аргумент функции - название метода обработки данных(см.ниже) для данного хранилища, а второй - данные.  
   В других хранилищах может быть метод с таким же названием и он выполнен не будет. Если нужно выполнить аптейд данных в нескольких кранилищах по метожу с одним наванием, то создай по одному инстансу для каждого хранилища, где необходимо изменить данные. И на каждом инстансе выполни функцию аптейда.  
2.В компоненте, который использует данные из хранилища:  
    а, б аналогичны. Аргументом при инициализации передай название хранилища, из которого будешь брать данные.
    Если нужно использовать несколько хранилищ, то есть несколько вариантов:  
        1)сделай несколько инстансов класса Galinka, в каждый единственным аргументом передай название соответствующего хранилища:  
         ```aidl
         const toDosStoreInstance = new Galinka('toDos');
         const someNextStoreInstance = new Galinka('someNextStore');
         ```
         и для каждого инстанса далее вызови метод  
         ```aidl
         const toDosStore = toDosStoreInstance.getStore();
         const someNextStore = someNextStoreInstance.getStore();
         ```
        возвращаться будет хранилище по названию, заданному аргументом при инициализации  
        2)сделай один инстанс класса Galinka, куда передай название любого(можно основного) хранилища.  
          ```
          const toDosStoreInstance = new Galinka('toDos');
          ```
          или без аргумента:  
          ```
          const toDosStoreInstance = new Galinka();
          ```
          и для каждого требуемого хранилища выполни:  
          ```
          const toDosStore = toDosStoreInstance.getStore('toDos');
          const someNextStore = toDosStoreInstance.getStore('someNextStore');
          ```
          то есть передавай аргументом в функцию getStore название требуемого хранилища  
          
          ВНИМАНИЕ!!! Если инициализируешь инстанс без аргумента:  
          ```
          const anonymousStore = new Galinka();
          ```
           то метод getStore, вызванный без аргумента не вернет никакое хранилище  
        3)сделай один инстанс класса Galinka, куда передай название любого(можно основного) хранилища.  
           ```
           const toDosStoreInstance = new Galinka('toDos');
           ```
           или без аргумента:  
           ```
           const toDosStoreInstance = new Galinka();
           ```
           для получения всех хранилищ выполни:  
           ```
           const allStores = toDosStoreInstance.getAllStores();
           ```
           из константы allStores получи необходимый store  
      в.В методе, который вызывается для компонента один раз, например ComponentDidMount, передай в Galinka аргументом в методе addStateFunc функцию для вызова перерендера. Для React просто передать setState данного компонента:  
        ```
        componentDidMount = () => {
            inputStore.addStateFunc(this.setState, 'toDos');
        };
    ```
     когда какое-то хранилище обновится, перерендеринг вызовется только для тех компонентов, которые используют данные из этого хранилища.  
3.Настройка функций обработки Хранилищ - storeConstructors:  
       Удобно выполнять в отдельной папке в отдельных файлах для каждого store.  
       В примере это папка /examples/storeConstructors, файл toDos.js  
       а)импортируй класс  
           ```
           import Galinka from '../../galinka';
           ```
       б)создай новый инстанс класса. Аргументом передать название хранилища.Здесь аргумент обязателен  
           ```
           const inputStoreInstance = new Galinka('toDos');
           ```
       в)задай все функции обработчики данного хранилища.  
       У каждой функции обработчика первый аргумент - данные, второй - старое хранилище.  
       Возвращать функция должна новый store:  
        ```sh
        const del = (id, oldState = []) => oldState.filter(item => !(item.id === id));
        const add = (data, oldState = []) => [data, ...oldState];
        ```
        Обрати внимание, я задаю дефолтное значение старого store в аргументе функции. Galinka ничего не знает о функциях-обработчиках,
        поэтому подобное дефолтное значение позволит избежать ошибок при первом обращении к функции.  
        г)Структура store - не зона ответственности Galinka. Ты задаешь структуру самостоятельно.  
        Хорошая практика - указывать структуру данного хранилища в начале файла:  
       ```sh
       const thisStoreStructure = [
       		{
       			id:'someUniqueId',
       			data:'some string data',
       		},
       		{
       			id:'someAnotherUniqueId',
       			data:'some another string data',
       		},
       	];
       	```
       	д)Добавь функции-обработчики текущего store. Для каждой функции создай объект вида  
       	   ```
       	   const addObj = {
           		type: 'add',
           		updateFunc: add,
           	};
           	const delObj = {
            		type: 'del',
            		updateFunc: del,
            	};
       	   ```
       	   где оба свойства - обязательные.  
       	   свойство из поля type ты потом будешь вызывать при обновлении хранилища (updateStore('add', data), см п.1)  
       	   свойство из поля update - это сама функция обработчик (const add = (data, oldState = []) => [data, ...oldState];)  
       	   
       	   далее есть 2 варианта:
       	   1)Функций несколько: на инстансе класса Galinka вызови функцию addStoreConstructors куда передай массив сформированных выше объектов:  
       	   ```
       	   toDos.addStoreConstructors([addFuncObj, delFuncObj]);
       	   ```
       	   2)Функция одна.на инстансе класса Galinka вызови функцию addStoreConstructor, куда передай сформированный выше объект:  
       	   ```
       	   toDos.addStoreConstructor(addFuncObj);
       	   ```
4.Дополнительные возможности.  
        При каждом обновлении store, старое состояние хранилищ сохраняется.  
        Можно использовать историю состояний. Метод getFullHistory вернет массив всех состояний, последовательно измененных  
       
       
